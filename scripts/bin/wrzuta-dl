#!/usr/bin/python2
#
# wrzuta-dl (ver. 0.3.0)
# Copyright (c) 2009-2011 Arkadiusz Bokowy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# If you want to read full version of the GNU General Public License
# see <http://www.gnu.org/licenses/>.
#
# ** Note: **
# For contact information and the latest version of this program see
# my webpage <http://arkq.awardspace.us/projects/wrzuta-dl.html>.
#
# Changelog:
#* Mon Jul 18 2011 Arkq <> 0.3.0
# - Wrzuta class rewritten
#* Mon Aug 23 2010 Arkq <arkbow@poczta.fm> 0.2.0
# - interactive mode with readline
#* Sat Jul 17 2010 Arkq <> 0.1.7
# - new movies paths determination (server side)
#* Sun May 16 2010 Arkq <> 0.1.6
# - 'playlist' content type related bug fix
# - add play command in interactive mode
#* Thu Oct 15 2009 Arkq <> 0.1.5
# - next search page print command in interactive mode
# - some error exception handling
#* Sat May 16 2009 Arkq <> 0.1.3
# - update search engine (wrzuta.pl has changed searching)
#* Sat Apr 24 2009 Arkq <> 0.1.2
# - bug fix: html parsing error (search engine)
# - download more then one file at once
#* Thu Jan 22 2009 Arkq <> 0.1.0
# - add interactive mode
#* Thu Jan 16 2009 Arkq <arkbow@poczta.fm> 0.0.1
# - initial work
#

APP_VER = '0.3.0'

import sys, re, subprocess
import urllib, urllib2
from optparse import OptionParser
from htmllib import HTMLParser

class Wrzuta:
	infoURL = 'http://%s/xml/plik/%s/wrzuta.pl/sa/666'

	def __init__(self, url = None):
		self.fileXMLInfo = None
		if url is not None: self.getFileXMLInfo(url)

	def checkURL(self, url):
		'''Check if the url is Wrzuta one, if yes return True.'''
		if re.search('\.wrzuta\.pl/.+', url) is None: return False
		else: return True

	def getFileXMLInfo(self, url):
		'''Get file information from server (in XML format).'''
		if self.checkURL(url) is False:
			self.fileXMLInfo = None
			return False

		# extract fileID from URL
		idPat = re.compile('[^/]+/([^/]+)/.+')
		(scheme, netloc, path, query, fragment) = urllib2.urlparse.urlsplit(url)
		try: fileID = idPat.search(path).group(1)
		except AttributeError:
			self.fileXMLInfo = None
			return False

		urlData = urllib2.urlopen(self.infoURL % (netloc, fileID))
		self.fileXMLInfo = urlData.read()
		urlData.close()

	def checkFileXMLInfoStatus(self):
		'''Check status of downloaded XML info file, if OK return True.'''
		if self.fileXMLInfo is None: return False
		status = re.search('<status>(.+)</status>', self.fileXMLInfo).group(1)
		if status == 'ok': return True
		else: return False

	def getDirectFileURL(self):
		'''Return URL which can be used to download file from server.'''
		if self.checkFileXMLInfoStatus() is False: return None

		pat = re.compile('<fileId><.*\[(.+)\]\]></fileId>')
		return pat.search(self.fileXMLInfo).group(1)

	def getFileName(self):
		'''Return file name which can be downloaded via getDirectFileURL().'''
		if self.checkFileXMLInfoStatus() is False: return None

		pat = re.compile('<name><.*\[(.+)\]\]></name>')
		return pat.search(self.fileXMLInfo).group(1) #no file extension here!

	def getFileExtension(self):
		'''Return file extension.'''
		if self.checkFileXMLInfoStatus() is False: return None
		typesList = {1:'flv', 2:'mp3'}

		pat = re.compile('<filetype>(.+)</filetype>')
		fType = pat.search(self.fileXMLInfo).group(1)
		return typesList[int(fType)]

	def getFileDescription(self, url):
		'''Return file description.'''
		if self.fileXMLStat is False: return None

		pat = re.compile('<description><.*\[(.+)\]\]></description>')
		return pat.search(self.fileXMLInfo).group(1)

class WrzutaSearch():
	searchURL = 'http://www.wrzuta.pl/szukaj/%s%s/%d' #search_type/query/page
	searchTypes = {'all':'', 'video':'filmow/', 'audio':'audio/',
			'image':'obrazow/', 'playlist':'playlist/'}

	# number of links (one type) on the search results pages
	allLinksCountOnPage = 15
	typeLinksCountOnPage = 30

	def seEngine(self, query, type, page):
		'''Search for data in Wrzuta server. This function returns wrzVideo, wrzAudio,
		wrzImage, where wrz* are lists (URL, title, size, duration).'''
		se_url = self.searchURL % (self.searchTypes[type], urllib.quote_plus(query), page)
		wrzVideo, wrzAudio, wrzList, wrzImage = [], [], [], []

		newContent = False
		parseContent = False
		for xLine in urllib2.urlopen(se_url):
			# switch into content parsing mode
			if parseContent is False:
				if xLine.find('<div id="found_files_container">') != -1:
					parseContent = True
				continue

			# check for new search results
			for x in ('video', 'audio', 'plst', ''):
				if xLine.find('class="file %s"' % x) != -1:
					wrzFileURL, wrzFileTitle = None, None
					wrzFileDuration, wrzFileSize = None, None
					newContent = True
			if newContent is False: continue

			# get file URL and title
			if xLine.find('class="title"') != -1:
				wrzFileURL = re.search('href="([^>]+)">', xLine).group(1)
				wrzFileTitle = unescapeHTML(re.search('">(.+)</a', xLine).group(1))
			# get file duration
			if xLine.find('class="duration"') != -1:
				wrzFileDuration = re.search('duration">([^>]+)<', xLine).group(1)

			# get file size (we dont need more data -> save what we've got)
			if xLine.find('class="size"') != -1:
				wrzFileSize = re.search('size">([^>]+)<', xLine).group(1)

				# create file information structure
				wrzFileData = (wrzFileURL, wrzFileTitle, wrzFileSize, wrzFileDuration)

				# save data to proprietary lists
				if wrzFileURL.find('/film/') != -1: wrzVideo.append(wrzFileData)
				elif wrzFileURL.find('/audio/') != -1: wrzAudio.append(wrzFileData)
				elif wrzFileURL.find('/playlista/') != -1: wrzList.append(wrzFileData)
				elif wrzFileURL.find('/obraz/') != -1: wrzImage.append(wrzFileData)

				newContent = False

		return wrzVideo, wrzAudio, wrzList, wrzImage

	def search(self, query, type = 'all', pageNb = 1, resultsNb = None):
		'''Search in Wrzuta server for query string starting from pageNb.
		If it is possible return 'resultsNb' number of results.'''
		results = [[],[],[],[]]

		# determine maximum number of results for this search
		if type == 'all': maxResults = self.allLinksCountOnPage
		else: maxResults = self.typeLinksCountOnPage

		if resultsNb is None: resultsNb = maxResults

		while True:
			# use basic search engine
			fndList = self.seEngine(query, type, pageNb)

			# concatenate search results 
			for x in range(len(results)): results[x] += fndList[x]

			# check if we need more results, if not break
			needMoreResults = True
			for x in results:
				if len(x) >= resultsNb: needMoreResults = False
			if needMoreResults is False: break

			# check if there might be more results, if not break
			isMoreResults = False
			for x in range(len(fndList)):
				if len(fndList[x]) == maxResults: isMoreResults = True
			if isMoreResults is False: break

			# get next results page
			pageNb += 1

		# trim fetched links to number defined by user
		for x in range(len(results)): del results[x][resultsNb:]

		return results

class WrzutaInteractive(WrzutaSearch, Wrzuta):
	commands = {'help':'cmd_help(', 'exit':None, 'play':'cmd_play(',
			's':'cmd_search("all",', 'sv':'cmd_search("video",', 'sa':'cmd_search("audio",',
			'si':'cmd_search("image",', 'next':'cmd_search("next",', 'dv':'cmd_dw(0,',
			'da':'cmd_dw(1,', 'di':'cmd_dw(2,'}

	def __init__(self):
		import readline
		readline.set_completer(self.completer)
		readline.parse_and_bind('tab: complete')
		self.fndList = None
		self.searchPage = 0

		print('If you don\'t know what to do, type `help` :)')
		while True:
			try: cmd = raw_input('wrzuta> ').strip()
			except EOFError: print('exit'); break
			except KeyboardInterrupt: print(''); break
			if cmd == 'exit': break
			if len(cmd) == 0: continue

			args = cmd.split(None, 1) + ['']
			if args[0] in self.commands.keys():
				eval('self.'+self.commands[args[0]]+'args)')
			else: print('%s: command not found' % args[0])

	def completer(self, text, state):
		if state == 0 and text:
			self.matches = [x + ' ' for x in self.commands.keys() if x.startswith(text)]
		elif state == 0: self.matches = self.commands.keys()
		try: return self.matches[state]
		except IndexError: return None

	def cmd_help(self, q):
		print("  exit\t\t\texit interactive mode\n"\
"  play NB\t\tplay audio with mpg123 player\n"\
"  s STRING\t\tsearch for STRING in server (all media)\n"\
"  sa|sv|si STRING\tsearch for audio|video|image\n"\
"  next\t\t\tretrieve next search results page\n"\
"  da|dv|di NB\t\tdownload audio|video|image (NB from search results)")

	def cmd_search(self, t, q):
		if t == 'next': #search on the next page
			if self.searchPage == 0:
				print('No next search page! Use "s*" first.')
				return
			self.searchPage += 1
		else:
			self.searchQ = q[1]  #save search query string
			self.searchType = t  #save search type
			self.searchPage = 1  #new search from first page

		try:
			self.fndList = self.search(self.searchQ, self.searchType, self.searchPage)
			if printSearchResults(self.fndList) is False:
				self.searchPage = 0
		except urllib2.URLError, err:
			print('Network error: %s' % err[0])
			self.searchPage = 0

	def cmd_dw(self, t, q):
		for nb in q[1].split():
			try:
				downloadAgent(self.fndList[t][int(nb)-1][0], background = True)
			except:
				print('Error: firstly use search command and/or enter correct NB to download (%s)' % nb)

	def cmd_play(self, q):
		for nb in q[1].split():
			try:
				self.getFileXMLInfo(self.fndList[1][int(nb)-1][0])
				print('Press `q` to stop playback')
				subprocess.call(['mpg123', '-qC', self.getDirectFileURL()])
			except:
				print('Error: firstly use search command and/or enter correct NB to play (%s)' % nb)

def unescapeHTML(s):
	'''Python sucks it this area..., so it is workaround.'''
	p = HTMLParser(None)
	p.save_bgn()
	p.feed(s)
	return p.save_end()

def printSearchResults(seResList, printURL = False, numbering = True):
	'''Print Wrzuta search results in the user friendly way.'''
	infoHeader = ('Video links:', 'Audio links:', 'Playlist links:', 'Photo links:')

	zeroResults = True
	for x in range(len(seResList)):
		if len(seResList[x]) == 0: continue
		zeroResults = False

		print(infoHeader[x])

		num = 1
		for xLink in seResList[x]:
			if numbering: numTxt = '%2d.' % num
			else: numTxt = 'Name'

			if xLink[3] is None: infoTxt = xLink[2]
			else: infoTxt = '%s | %s' % (xLink[2], xLink[3])

			print(' %s: "%s", Info: %s' % (numTxt, xLink[1], infoTxt))
			if printURL: print('   URL: %s' % xLink[0])
			num += 1

	# indicate if we had results or we hadn't
	if zeroResults:
		print('No search results.')
		return False
	else: return True

def downloadAgent(dwLink, background = False, quiet = False):
	wt = Wrzuta(dwLink)
	fileURL = wt.getDirectFileURL()
	fileName = wt.getFileName().replace('/', '_') + '.' + wt.getFileExtension()

	print('Saving file as: %s' % fileName)

	wgetCall = ['wget', '-O', fileName, fileURL]
	if background: subprocess.Popen(wgetCall + ['-nv'])
	else:
		if quiet: wgetOption += ['-q']
		subprocess.call(wgetCall)

# ---===+++ MAIN +++===---
if __name__ == '__main__':
	optp = OptionParser(usage='Usage: %prog [options] {url(s)|text}', version=APP_VER)
	optp.add_option('-i', '--interactive', help='go into interactive mode '
			'(with prompter)', action='store_true', dest='interactive')
	optp.add_option('-g', '--get-url', help='print final URL only',
			action='store_true', dest='get_url')
	optp.add_option('-s', '--search', help='search for given text '
			'(in place of URL)', action='store_true', dest='search')
	optp.add_option('-t', '--title', help='display title when "-g" is used',
			action='store_true', dest='get_title')
	optp.add_option('-q', '--quiet', help='activates quiet mode',
			action='store_true', dest='quiet')
	optp.add_option('-U', '--show-url', help='show URLs in search mode',
			action='store_true', dest='show_url')
	optp.add_option('--setyp', help='search type [Avai] (default: A)',
			action='store', type='string', default='A', dest='ST')

	cmd_opts, cmd_args = optp.parse_args()
	if len(cmd_args) == 0 and not cmd_opts.interactive:
		optp.print_help()
		sys.exit(1)

	if cmd_opts.interactive: #interactive mode
		WrzutaInteractive()
		sys.exit(0)

	if cmd_opts.search: #search mode
		sType = {'A':'all', 'v':'video', 'a':'audio', 'i':'image'}
		query = ''.join([x + '+' for x in cmd_args])[:-1]

		ws = WrzutaSearch()
		fndList = ws.search(query, sType)
		printSearchResults(fndList, cmd_opts.show_url)
		sys.exit(0)

	wt = Wrzuta()
	for xurl in cmd_args:
		wt.getFileXMLInfo(xurl)

		if cmd_opts.get_url: #only print direct file URL
			if cmd_opts.get_title: print(wt.getFileName())
			print(wt.getDirectFileURL())
		else: #simple download mode
			downloadAgent(xurl, quiet = cmd_opts.quiet)
